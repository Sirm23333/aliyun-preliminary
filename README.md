### 原生编程挑战赛3：服务网格控制面分治体系构建

队伍:本地小有名气的年轻人们

最终分数:7696.0186

历史最好分数:7545.4066

下面是对整个目录结构和最终的主要算法做简单的介绍 : )

#### 1.工程目录结构

- controller包下为三个接口
- constant下包含公用的常量参数
- service下为主要的实现逻辑,最终迭代版本为iter11_syp_0625版本
  - model包下为对题目中相关概念的封装类,使用bitmap位图来表示应用对服务的依赖关系,可以在节省空间的前提下,通过位运算来更快的求得应用之间的相似度以及更快的合并应用
  - Game类为主要的算法逻辑,最终我们采用博弈的思想解题
  - GlobalContain为全局变量
  - Iter11DataHandler为数据处理相关工具类
  - Iter11MainRunImpl为controller调用实现类
- util为工具包

#### 2.主要算法描述

赛道三的问题是一个多目标优化问题,具体为非线性的整数规划组合优化问题,类似多维装箱问题模型.需要考虑实际加载内存,pilot加载内存标准差和连接标准差三个目标.但由于给出来明确的目标函数,所以可以直接用解单目标优化的方式解题.



##### A.传统启发式算法

整个赛期我们尝试过三个大的方向,最开始使用传统算法,使用最优匹配原则将应用分配到pilot.通过多次迭代分配,找出一组最优的权重作用于三个参数.最终最好的得分在1w6左右.



##### B.GA算法

第一种方法跑出成绩后,进而我们转向了现代优化算法和均衡博弈方向.首先尝试GA遗传算法,也是花费时间最多的方案,但始终无法进入1w分门槛.下面对遗传算法主要逻辑描述:

- 编码

染色体中每一个基因代表一个pilot,基因为一个固定长度的0/1串,染色体第x个基因的第n位为1,则表示$app_n$分配到$pilot_x$上(类似bitmap)

- 编码的标准化

为了减少决策空间太多的冗余,进行编码的标准化,假设pilot编号为1~m , appi为第一个分配到pilotm的app,保证对于所有的j < i , appj分配到的pilot的编号不大于app(j+1)

- 选择算子

使用竞标和轮赌的选择算子,并引入精英保留策略

- 交叉算子

两个染色体交叉,随机选择多个pilot就行交换,交换规则为:

将父代1选中的pilot完全不变的替换父代2的相应的pilot,将父代2中其他的pilot中重复的app位置0,并将缺失的app按照最佳匹配算法分配到某个pilot中

父代2选中的pilot与父代1进行相同的操作

- 变异算子

随机选择多个app,按照最优匹配原则重新分配到新的pilot



##### C.博弈

遗传算法因为数据规模问题和时间限制问题,最后收敛性和稳定性并不是很好,最终没能达到预想的效果,使用进化算法还有很多可改进的点.在比赛中后期,我们发现使用博弈的思想解题提分明显,直接干进了9000分,最终放弃的进化算法,采用博弈思想解题.

我们最终使用了合并+博弈的思想解题.大体思路是博弈可以很好将各个参赛者(pilot)打到一个十分均衡的状态,而配合对app的预处理合并,可以将比例控制的尽量小一点.通过调制合并的相关参数,将比例和标准差的乘积尽可能打低.

- 关于合并

将依赖服务所占内存相似度达到一定值的应用进行合并,代码中共做了两次合并,两次合并定义的相似度不同.

第一次的相似度为jac相似度,即 交集内存/并集内存 , 为了将依赖服务和规模都相似的app合并

第二次的相似度为覆盖性的相似,即 交集内存/小集合内存 , 为了将某些小app向大app中合并

因后面涉及到拆分的步骤,分别就原始app集合,第一次合并后的app集合,第二次合并后的app集合表示为A,B,C

- 关于博弈

首先对C进行博弈分配.算法的大体流程为:随机选择一个app,若移动该app可以使整体的价值函数(即本题的目标函数)降低,则选择一个降低最高的pilot移入,否则继续随机选择另一个app,直到所有的app都无法再移动,达到一个平衡的状态.然后通过随机打乱均衡状态,继续新一轮博弈,取多次尝试后,目标函数最低的一次作为最终的分配结果Y1

对Y1中的app进行拆分,(即将C集合拆为B集合),重新博弈到一个最低分,记这次结果为Y2

对Y2中的app进行拆分,(即将B集合拆为A集合),重新博弈到一个最低分,这即第一阶段的最终结果

对于第二阶段,因为内存只增不减的性质,对博弈思想是十分有力的,理论上使用该方法是可以把标准差打到很低,所以在第二阶段我们侧重了标准差优势,稍微对比例放宽了要求,大致流程同上,只是在将价值函数定义为标准差的和,而在预分配和打乱阶段,考虑比例因素.(采用这样,分数降到了8000以内)

最终因为超时直接99999999,为了避免偶尔的超时现象,加入了时间限制,当达到规定时间,结束迭代直接返回目前最优结果



