### 原生编程挑战赛3：服务网格控制面分治体系构建

队伍:本地小有名气的年轻人们

最终分数:7696.0186

历史最好分数:7545.4066

最终排名:1

#### 1.题目解析

赛题链接:https://code.aliyun.com/middleware-contest-2020/pilotset

导师解析:https://tianchi.aliyun.com/forum/postDetail?postId=109732

#### 2.工程目录结构

- controller包下为三个接口
- constant下包含公用的常量参数
- service下为主要的实现逻辑,最终迭代版本为iter11_syp_0625版本
  - model包下为对题目中相关概念的封装类,使用bitmap位图来表示应用对服务的依赖关系,可以在节省空间的前提下,通过位运算来更快的求得应用之间的相似度以及更快的合并应用
  - Game类为主要的算法逻辑,最终我们采用博弈的思想解题
  - GlobalContain为全局变量
  - Iter11DataHandler为数据处理相关工具类
  - Iter11MainRunImpl为controller调用实现类
- util为工具包

#### 3.算法描述

赛道三的问题是一个多目标优化问题,具体为非线性的整数规划组合优化问题,类似多维装箱问题模型.需要考虑实际加载内存,pilot加载内存标准差和连接标准差三个目标.但由于给出来明确的目标函数,所以可以直接用解单目标优化的方式解题.

##### A.传统启发式算法

整个赛期我们尝试过三个大的方向,最开始使用传统算法,使用最优匹配原则将应用分配到pilot.通过多次迭代分配,找出一组最优的权重作用于三个参数.得分固定在1w6.

流程大体如下:

- 将所有的app按照依赖服务内存由多到少排序

- 对排序后的app依次进行分配,拿到一个app~i~,将它分配到一个pilot会有一个资源损耗分数score,其由上述三个目标参数决定,详细来说,将app~i~分配到pilot~j~的分数为:

  $$score(i,j)=weight[0]*JD(i,j)+weight[1]*memScore(i,j)+weight[2]*conScore(i,j)$$

  其中,JD(i,j)为Jaccard distance (i,j),即app~i~和pilot~j~依赖内存的Jaccard距离,定义为:

  $$JD(i,j)=1-J(i,j)=1-\frac{M_{app_i}\bigcap M_{pilot_j}}{M_{app_i}\bigcup M_{pilot_j}}$$, J(i,j)为jaccard相似度

  $$memScore(i,j)=\frac{M_{pilot_j}}{M_{服务内存}}$$

  $$conScore(i,j)=\frac{C_{pilot_j}}{C_{总连接数}}$$

  weight为权重向量

  每一次分配,将app~i~分配到Min{score(i,j)}的pilot~j~

- 尝试不同的weight权重,取最优的一个作为结果返回

##### B.进化算法

第一种方法跑出成绩后,我们转向了现代优化算法和均衡博弈方向.首先尝试进化算法,使用GA遗传算法,也是花费时间最多的方案,但线上问题规模较大,在有时间限制的情况下,始终无法很好的收敛的理想的结果,分数最终也没有进到1w.下面对遗传算法主要逻辑描述:

- 合并

  为了降低问题的复杂度,选择先一步降维,通过合并相似度高的app来减少app的数量,将相似度高的app组合分配.合并的方式采用了两种

  - 基于app依赖内存的相似度合并,$J(i,j)=\frac{M_{app_i}\bigcap M_{pilot_j}}{M_{app_i}\bigcup M_{pilot_j}}$
  - 基于app依赖内存的包含度合并,$C(i,j)=\frac{M_{app_i}\bigcap M_{pilot_j}}{M_{pilot_j}}$

- 编码

  染色体中每一个基因代表一个pilot,基因为一个固定长度的0/1串,染色体第x个基因的第n位为1,则表示$app_n$分配到$pilot_x$上(类似bitmap)

- 编码的标准化

  为了减少决策空间太多的冗余,进行编码的标准化,假设pilot编号为1~m , appi为第一个分配到pilotm的app,保证对于所有的j < i , appj分配到的pilot的编号不大于app(j+1)

- 选择算子

  使用竞标和轮赌的选择算子,并引入精英保留策略

- 交叉算子

  两个染色体交叉,随机选择多个pilot就行交换,交换规则为:

  将父代1选中的pilot完全不变的替换父代2的相应的pilot,将父代2中其他的pilot中重复的app位置0,并将缺失的app按照最佳匹配算法分配到某个pilot中

  父代2选中的pilot与父代1进行相同的操作

- 变异算子

  随机选择多个app,按照最优匹配原则重新分配到新的pilot

##### C.贪婪博弈

遗传算法因为数据规模问题和时间限制问题,最后收敛性和稳定性并不是很好,最终没能达到预想的效果,使用进化算法还有很多可改进的点.

在比赛中后期,我们发现使用贪婪博弈的思想解题提分明显,直接干进了9000分,最终放弃的进化算法,采用博弈思想解题.

我们最终使用了合并+博弈的思想解题.大体思路是博弈可以很好将各个参赛者(pilot)打到一个十分均衡的状态,而配合对app的预处理合并,可以将比例控制的尽量小一点.通过调制合并的相关参数,将比例和标准差的乘积尽可能打低.

- 合并

将依赖服务所占内存相似度达到一定值的应用进行合并,代码中共做了两次合并,合并原则同上

- 博弈

首先对C进行博弈分配.算法的大体流程为:随机选择一个app,若移动该app可以使整体的价值函数(即本题的目标函数)降低,则选择一个降低最高的pilot移入,否则继续随机选择另一个app,直到所有的app都无法再移动,达到一个平衡的状态.然后通过随机打乱均衡状态,继续新一轮博弈,取多次尝试后,目标函数最低的一次作为最终的分配结果Y1

对Y1中的app进行拆分,(即将C集合拆为B集合),重新博弈到一个最低分,记这次结果为Y2

对Y2中的app进行拆分,(即将B集合拆为A集合),重新博弈到一个最低分,这即第一阶段的最终结果

对于第二阶段,因为内存只增不减的性质,对博弈思想是十分有力的,理论上使用该方法是可以把标准差打到很低,所以在第二阶段我们侧重了标准差优势,稍微对比例放宽了要求,大致流程同上,只是在将价值函数定义为标准差的和,而在预分配和打乱阶段,考虑比例因素.(采用这样,分数降到了8000以内)

最终因为超时直接99999999,为了避免偶尔的超时现象,加入了时间限制,当达到规定时间,结束迭代直接返回目前最优结果



